from struct import *
import rdm
from obj import *


def unpack_v_index(data):
    if len(data) == 2:
        out, = unpack('H', data)
    elif len(data) == 4:
        out, = unpack('I', data)
    else:
        out = None
    return out


def convert_normal2obj(norm):
    n_1 = [n * 1. / 255 * 2 - 1 for n in norm]
    return n_1


def convert_normal2rdm(norm):
    return [int((n + 1) * 255 / 2) for n in norm]


def padding(vec, length):
    if len(vec) < length:
        return vec + [0] * (length - len(vec))
    return vec


# we first try the 'P4h_N4b_T2h_I4b' vertex format
def obj_to_rdm(obj_file):
    # First we parse groups of faces from the obj file
    groups = {}
    vertices = []
    faces = []
    materials = []

    obj_v = obj_file.vertices
    obj_n = obj_file.normals
    obj_t = obj_file.uv

    n = 0
    for i, obj in enumerate(obj_file.objects):
        groups['group_{:}'.format(i)] = rdm.Group(offset=n, size=len(obj.faces) * 3, n=i)
        # TODO: check if more than 3 vertices per face
        for k, face in enumerate(obj.faces):
            for v in face:
                if v in vertices:
                    new_index = vertices.index(v)
                else:
                    vertices.append(v)
                    new_index = len(vertices)-1

                faces.append(rdm.VertexIndex(format='I', index=new_index).pack())
                n += 1
        name = rdm.AnnoString('group_{:}'.format(i).encode('ascii'))
        texture = rdm.AnnoString('dummy_texture.tga'.encode('ascii'))
        materials.append(rdm.Material(name=name, texture=texture, flag=rdm.SingleInt(0)))


    #Now we parse all vertices
    rdm_vertices = [rdm.Vertex({'vformat': 'P4h_N4b_T2h_I4b',
                         'pos': padding(obj_v[v[0]-1], 4),
                         'norm': convert_normal2rdm(padding(obj_n[v[2]-1], 4)),
                         'tex': obj_t[v[1]-1],
                         'unknown_I': (0, 0, 0, 0)}).pack() for v in vertices]

    # Now we create all the necessary records
    mesh_strings = rdm.StringRecord.from_strings(['mesh_name'] + [None] * 6)
    unknown_0 = rdm.UnknownRecord.from_list(
        [rdm.IntArray([(0, 6, 0, 4), (1, 5, 6, 1), (2, 5, 6, 1), (3, 5, 6, 1), (4, 6, 0, 2)])] + [None] * 5)
    unknown_1 = rdm.IntArray([(3, 0, 0, 0, 0)])
    mesh_flags = {'unknown_{:}'.format(i + 2): rdm.SingleInt(v) for i, v in enumerate(
        [4294967295, 3229040640, 3214516224, 3227828224, 1082277888, 1078779904, 1079975936] + 10 * [0])}
    mesh_record = rdm.MeshRecord({**{'strings': mesh_strings,
                                     'unknown_0': unknown_0,
                                     'unknown_1': unknown_1,
                                     'vertices': rdm.DataArray(rdm_vertices),
                                     'faces': rdm.DataArray(faces),
                                     'groups': rdm.GroupRecord(groups)}, **mesh_flags})

    string_record = rdm.StringRecord.from_strings(
        ['generated by VonZeeple\'s awesome rdm converter', 'static_norm.rmp'] + [None] * 16)

    flags = {'unknown_{:}'.format(i): v for i, v in enumerate([None] * 9)}

    materials_record = rdm.MaterialsRecord({'material_{:}'.format(i): m for i, m in enumerate(materials)})
    main_record = rdm.MainRecord({**{'strings': string_record, 'mesh': mesh_record, 'materials': materials_record},
                                  **flags})

    rdm_file = rdm.RDMFile(rdm_tag='RDM', dummy_char=1, unknown_0=[20, 0, 4, 28], main_record=main_record)
    return rdm_file


def rdm_to_obj(rdm_file):
    raw_vertices = rdm_file.main_record.get('mesh', {}).get('vertices')
    vertices = [rdm.Vertex.parse(data) for data in raw_vertices]
    groups = list(rdm_file.main_record.get('mesh', {}).get('groups', {}).values())
    raw_faces = rdm_file.main_record.get('mesh', {}).get('faces')
    faces_v_indices = [unpack_v_index(data) for data in raw_faces]
    materials = list(rdm_file.main_record.get('materials', {}).values())

    obj_objects = []
    obj_v = [vertices[i]['pos'] for i in range(len(vertices))]
    obj_n = [convert_normal2obj(vertices[i]['norm']) for i in range(len(vertices))]
    obj_uv = [vertices[i]['tex'] for i in range(len(vertices))]

    for p, group in enumerate(groups):
        name = materials[p].name.decode('ascii')
        n0 = int(group.offset)
        n1 = int(n0 + group.size)
        group_v_index = faces_v_indices[n0: n1]

        faces = [group_v_index[p:p + 3] for p in range(0, len(group_v_index), 3)]
        obj_f = [[[f[0] + 1] * 3, [f[1] + 1] * 3, [f[2] + 1] * 3] for f in faces]

        obj_objects.append(OBJObject(name=name, faces=obj_f))

    obj_file = OBJFile(vertices=obj_v, normals=obj_n, uv=obj_uv, objects=obj_objects)
    return obj_file
